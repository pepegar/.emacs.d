* Emacs configuration

This is my emacs configuration, this time in Org mode.  The previous
working version of it was [[https://github.com/pepegar/emacs.d/tree/d6c5ef558fc4a28f7b107a4edb5c1383886a23d6][this commit]].

The idea behind using org mode for this is that I can get rid of all
these cheatsheets I've flying around my system (and also physical
desk) and have both the emacs-lisp code, the notes, and the
cheatsheets all here.


** Initial configuration
*** Some personal information

#+BEGIN_SRC emacs-lisp
(setq user-full-name "Pepe García"
      user-mail-address "jl.garhdez@gmail.com")
#+END_SRC

*** Help emacs find my executables


#+BEGIN_SRC emacs-lisp
(setq exec-path (append exec-path '("/usr/bin")))
(setq exec-path (append exec-path '("/usr/local/bin")))
(setq exec-path (append exec-path '("/Users/pepe/.local/bin")))
(setq exec-path (append exec-path '("/Users/pepe/.nix-profile/bin")))
(setq exec-path (append exec-path '("/nix/var/nix/profiles/default/bin/")))
#+END_SRC

*** plumbing

    To tell emacs that all saves should go to the ~/.backups~ folder.

#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist `(("." . "~/.backups")))
#+END_SRC

    Save the custom variables to ~\~/.emacs.d/custom.el~

#+BEGIN_SRC emacs-lisp
(setq custom-file "~/.emacs.d/custom.el")
(load custom-file)
#+END_SRC

*** ~use-package~

   I manage all the packages for my emacs configuration through the
   fantastic [[https://github.com/jwiegley/use-package][use-package]]. Here's how to get it:

#+BEGIN_SRC emacs-lisp
(require 'package)

(setq package-enable-at-startup nil)
(add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/"))
(add-to-list 'package-archives '("marmalade" . "http://marmalade-repo.org/packages/"))
(add-to-list 'package-archives '("melpa-stable" . "http://stable.melpa.org/packages/"))
(add-to-list 'package-archives '("gnu" . "http://elpa.gnu.org/packages/"))
(package-initialize)

(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

(eval-when-compile
  (require 'use-package))

(require 'bind-key)

(setq use-package-always-defer t
      use-package-always-ensure t)
#+END_SRC

*** Appearance

    Select the font size, family...

#+BEGIN_SRC emacs-lisp
(set-face-attribute
 'default nil :family "PragmataPro Mono Liga"
 :height 130)

(use-package all-the-icons)

(use-package rainbow-delimiters
  :demand
  :hook (emacs-lisp-mode-hook . rainbow-delimiters-mode))

(use-package all-the-icons-dired
  :hook (dired-mode-hook . all-the-icons-dired-mode))

(use-package pragmatapro
  :load-path "~/.emacs.d/lisp")

(use-package page-break-lines
  :pin melpa-stable
 )

(use-package dashboard
  :pin melpa-stable
  :demand
  :if (< (length command-line-args) 2)
  :config
  (defun dashboard-load-packages (list-size)
    (insert (make-string (ceiling (max 0 (- dashboard-banner-length 38)) 2) ? )
            (format "[%d packages loaded in %s]" (length package-activated-list) (emacs-init-time))))

  (add-to-list 'dashboard-item-generators '(packages . dashboard-load-packages))

  (setq dashboard-items '((packages)
                          (projects . 5)
                          (recents . 5)
                          (agenda))
        dashboard-startup-banner 'logo)
  (setq dashboard-set-heading-icons t)
  (setq dashboard-set-file-icons t)
  (dashboard-setup-startup-hook))

(use-package golden-ratio
  :ensure t
  :delight
  :init (golden-ratio-mode 1)
        (setq golden-ratio-auto-scale t))
#+END_SRC

*** maintaining selected theme between sessions

    I think I got all this from @anler, but am not sure :)

#+BEGIN_SRC emacs-lisp
(defun my-load-saved-theme ()
  (interactive)
  (when (file-exists-p my-saved-theme-filename)
    (let ((theme (intern (with-temp-buffer
                           (insert-file-contents my-saved-theme-filename)
                           (buffer-string)))))
      (unless (eq theme 'default)
        (load-theme theme :no-confirm)))))

(add-hook 'after-init-hook #'my-load-saved-theme)

(defvar my-load-theme-hook
  nil
  "Hooks to run after loading a theme.")

(defvar my-saved-theme-filename "~/.emacs.d/.emacs-theme")

(advice-add 'load-theme :after #'my-save-theme)
(advice-add 'disable-theme :after #'my-save-default-theme)
(advice-add 'load-theme :after #'my-run-theme-hooks)

(defun my-run-theme-hooks (theme &optional no-confirm no-enable)
  (run-hooks 'my-load-theme-hook))

(defun my-save-default-theme (disabled-theme)
  (my-save-theme 'default))

(defun my-save-theme (theme &optional no-confirm no-enable)
  (with-temp-buffer
    (insert (symbol-name theme))
    (when (file-writable-p my-saved-theme-filename)
      (write-region (point-min)
                    (point-max)
                    my-saved-theme-filename))))
#+END_SRC

*** Font locking

#+BEGIN_SRC emacs-lisp
(global-font-lock-mode 1)
#+END_SRC

*** update packages
#+BEGIN_SRC emacs-lisp
(use-package auto-package-update
   :custom
   (auto-package-update-delete-old-versions t))
#+END_SRC

** Tools
*** move-text

    Move text is for... moving text around :D

    Current keybindings i'm using are ~M-<UP>~ and ~M-<DOWN>~.

#+BEGIN_SRC emacs-lisp
(use-package move-text
  :config (move-text-default-bindings))
#+END_SRC

*** company
    Company is an autocompletion framework for emacs!

#+BEGIN_SRC emacs-lisp
(use-package company
  :bind (("M-n" . company-complete)))
#+END_SRC
*** paredit

#+BEGIN_SRC emacs-lisp
(use-package paredit
  :config
  (add-hook 'emacs-lisp-mode-hook #'paredit-mode)
  (add-hook 'lisp-interaction-mode-hook #'paredit-mode)
  (add-hook 'ielm-mode-hook #'paredit-mode)
  (add-hook 'lisp-mode-hook #'paredit-mode)
  (add-hook 'eval-expression-minibuffer-setup-hook #'paredit-mode))
#+END_SRC

*** Gnus

    Gnus is for email within emacs.  Its configuration is in ~\~/.emacs.d/gnus.org~

*** Erc

    Erc is an IRC client for emacs.

#+BEGIN_SRC emacs-lisp
(use-package erc
  :config
    (setq erc-modules '(autojoin notifications)))
#+END_SRC

*** Magit

    Magit is a better way to use git, from within emacs, of course.

#+BEGIN_SRC emacs-lisp
(use-package magit)
#+END_SRC

    There are several tricks I like to do with Magit.

**** commit & spinoff branch

     Normally, when I work on a small patch for a project I don't
     directly start creating the feature branch, but first create the
     commit/commits that solve the issue and then create the branch &
     pull request.

     I do this by fixing and creating the commits normally (on top of
     ~master~), and then within the magit screen, I just hit ~b s~,
     making a spinoff of master, with the last commits.  This is so
     convenient :)

**** Magit forges

     Let's try magit forge...

#+BEGIN_SRC emacs-lisp
(use-package forge)
#+END_SRC

     It returns an error while trying to get notifications...

*** Projectile

#+BEGIN_SRC emacs-lisp
(use-package projectile
  :config
  (projectile-global-mode)
  (setq projectile-mode-line
        '(:eval (format " [%s]" (projectile-project-name))))
  (setq projectile-remember-window-configs t)
  (setq projectile-completion-system 'ivy))
#+END_SRC
*** Diminish

    You don't always want the minor modes you're using to appear on
    the modeline, that's what ~diminish~ is for.

#+BEGIN_SRC emacs-lisp
(use-package diminish
  :pin melpa-stable)
#+END_SRC

*** Modeline

#+BEGIN_SRC emacs-lisp
(use-package doom-modeline
   :hook   (after-init . doom-modeline-mode)
   :custom
   (doom-modeline-buffer-file-name-style 'relative-to-project)
   (doom-modeline-height 15)
   (doom-modeline-major-mode-color-icon t))
#+END_SRC
*** Flycheck

    Flycheck is a spellchecker.  Truth be told, I don't use it very
    much... but yeah, here it is!

#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :pin melpa-stable
  :commands global-flycheck-mode)
#+END_SRC

*** Ivy, counsel, swiper

    I'm mostly a helm user, but want to give ivy a try now.  Ivy comes
    out of the box with ~counsel~ and ~swiper~.

#+BEGIN_SRC emacs-lisp
(use-package ivy
  :diminish ivy-mode
  :bind (("C-x C-b" . ivy-switch-buffer))
  :config
      (setq ivy-use-virtual-buffers t
            ivy-count-format "%d/%d "
            ivy-re-builders-alist '((swiper . ivy--regex-plus))))

(use-package flx)

(use-package counsel
  :bind (("M-x"     . counsel-M-x)
         ([f9]      . counsel-load-theme))
  :config
    (setq ivy-initial-inputs-alist nil))

(use-package counsel-projectile
  :bind (("C-c a g" . counsel-ag)
         ("C-x C-f" . counsel-find-file)
         ("C-c p h" . counsel-projectile)
         ("C-c p r" . projectile-replace)
         ("C-c p v" . projectile-vc)
         ("C-c p p" . counsel-projectile-switch-project)))

(use-package swiper
  :bind (("C-s" . swiper)
         ("M-l" . swiper-avy)))

(use-package ivy-posframe
  :after ivy
  :config
  (setq ivy-posframe-display-functions-alist '((t . ivy-posframe-display-at-frame-center)))
  (setq ivy-posframe-parameters '((left-fringe . 15)
                                  (right-fringe . 15)
                                  (top-fringe . 15)
                                  (bottom-fringe . 15)))
  (ivy-posframe-mode 1))
#+END_SRC

*** ace-window

    ace-window is a better ~other-window~.

#+BEGIN_SRC emacs-lisp
(use-package ace-window
  :bind (("M-o" . ace-window)))
#+END_SRC


*** posframe

    posframe is a package for showing a small child frame within the
    current frame.  Currently only used by hydra

#+BEGIN_SRC emacs-lisp
(use-package posframe)
#+END_SRC

*** Hydra

    Hydra allows me to create menus of keybindings.  I have several
    ones, for accessing my dotfiles, spelllchecking, going to my org
    files...

#+BEGIN_SRC emacs-lisp
(use-package hydra
  :bind (("C-x t" . toggle/body)
	 ("C-x j" . gotoline/body)
	 ("C-x c" . orghydra/body)
	 ("C-x p" . dotfiles/body))
  :custom
  (hydra-hint-display-type 'posframe)
  :config
  (defhydra toggle (:color blue)
    "toggle"
    ("a" abbrev-mode "abbrev")
    ("s" flyspell-mode "flyspell")
    ("f" flycheck-mode "flycheck")
    ("d" toggle-debug-on-error "debug")
    ("c" fci-mode "fCi")
    ("t" toggle-truncate-lines "truncate")
    ("w" whitespace-mode "whitespace")
    ("q" nil "cancel"))

  (defhydra orghydra (:color blue)
    "org"
    ("i" org-clock-in "clock in")
    ("o" org-clock-out "clock out")
    ("n" (find-file "~/org/notes.org") "notes.org")
    ("I" (find-file "~/org/i.org") "i.org")
    ("q" nil "cancel"))

  (defhydra dotfiles (:color black)
    "dotfiles"
    ("c" (find-file "~/.emacs.d/config.org") "config.org")
    ("z" (find-file "~/.zshrc") "zshrc")
    ("g" (find-file "~/.emacs.d/gnus.org") "gnus")
    ("q" nil "cancel"))

  (defhydra gotoline
    ( :pre (linum-mode 1)
	   :post (linum-mode -1))
    "goto"
    ("t" (lambda () (interactive)(move-to-window-line-top-bottom 0)) "top")
    ("b" (lambda () (interactive)(move-to-window-line-top-bottom -1)) "bottom")
    ("m" (lambda () (interactive)(move-to-window-line-top-bottom)) "middle")
    ("e" (lambda () (interactive)(end-of-buffer)) "end")
    ("c" recenter-top-bottom "recenter")
    ("n" next-line "down")
    ("p" (lambda () (interactive) (forward-line -1))  "up")
    ("g" goto-line "goto-line")))
#+END_SRC

*** Restclient

    Restclient is an awesome tool that allows you to describe HTTP
    request in plain text and execute them.  From [fn:1]their readme:

    | keybinding | action                                                                                         |
    |------------+------------------------------------------------------------------------------------------------|
    | ~C-c C-c~  | runs the query under the cursor, tries to pretty-print the response (if possible)              |
    | ~C-c C-r~  | same, but doesn't do anything with the response, just shows the buffer                         |
    | ~C-c C-v~  | same as C-c C-c, but doesn't switch focus to other window                                      |
    | ~C-c C-p~  | jump to the previous query                                                                     |
    | ~C-c C-n~  | jump to the next query                                                                         |
    | ~C-c C-.~  | mark the query under the cursor                                                                |
    | ~C-c C-u~  | copy query under the cursor as a curl command                                                  |
    | ~C-c C-g~  | start a helm session with sources for variables and requests (if helm is available, of course) |
    | ~C-c n n~  | narrow to regi                                                                                 |

#+BEGIN_SRC emacs-lisp
(use-package restclient
  :mode (("\\.http\\'" . restclient-mode)))
#+END_SRC

*** Org mode

    I try to write down everything in org mode, and to keep it
    updated.  This is my current configuration.

#+BEGIN_SRC emacs-lisp
(use-package org
  :bind (("C-c a a" . org-agenda)
	 ("C-c c" . counsel-org-capture))
  :config

  (unless (boundp 'org-export-latex-classes)
    (setq org-export-latex-classes nil))
  (add-to-list 'org-export-latex-classes
    ;; beamer class, for presentations
    '("beamer"
       "\\documentclass[11pt]{beamer}\n
        \\mode<{{{beamermode}}}>\n
        \\usetheme{{{{beamertheme}}}}\n
        \\usecolortheme{{{{beamercolortheme}}}}\n
        \\beamertemplateballitem\n
        \\setbeameroption{show notes}
        \\usepackage[utf8]{inputenc}\n
        \\usepackage[T1]{fontenc}\n
        \\usepackage{hyperref}\n
        \\usepackage{color}
        \\usepackage{listings}
        \\lstset{numbers=none,language=[ISO]C++,tabsize=4,
    frame=single,
    basicstyle=\\small,
    showspaces=false,showstringspaces=false,
    showtabs=false,
    keywordstyle=\\color{blue}\\bfseries,
    commentstyle=\\color{red},
    }\n
        \\usepackage{verbatim}\n
        \\institute{{{{beamerinstitute}}}}\n          
         \\subject{{{{beamersubject}}}}\n"
  
       ("\\section{%s}" . "\\section*{%s}")
       
       ("\\begin{frame}[fragile]\\frametitle{%s}"
         "\\end{frame}"
         "\\begin{frame}[fragile]\\frametitle{%s}"
         "\\end{frame}")))

  (org-babel-do-load-languages
   'org-babel-load-languages
   '((dot . t)
     (mscgen . t)
     (python . t)
     (restclient . t)
     (haskell . t)))
  (setq org-agenda-files '("~/org/")
	org-capture-templates '(("t" "To Do Item" entry (file+headline "~/org/i.org" "Work") "* TODO %?\n%T" :prepend t)
				("o" "opensource" entry (file+headline "~/org/i.org" "Opensource") "* TODO %?\n%T" :prepend t)
				("p" "Personal To Do Item" entry (file+headline "~/org/i.org" "Personal") "* TODO %?\n%T" :prepend t))
	org-src-fontify-natively t))


(use-package ob-restclient
  :after org)

(use-package org-bullets
  :after org
  :commands (org-bullets-mode)
  :init (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))

(use-package org-present
  :after org)
#+END_SRC

*** Multiple cursors

#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors
  :bind (("C-* l" . mc/edit-lines)
	 ("C->" . mc/mark-next-like-this)
	 ("C-<" . mc/mark-previous-like-this)
         ("C-* C-*" . mc/mark-all-like-this)
         ("C-c C-* C-*" . mc/mark-more-like-this)
         ("C-* i" . mc/insert-numbers)
         ("C-* s" . mc/sort-regions)
         ("C-* r" . mc/reverse-regions)
         ("M-<mouse-1>" . mc/add-cursor-on-click))
  :init
  (global-unset-key (kbd "M-<down-mouse-1>"))
  :config
  (require 'mc-extras))

(use-package mc-extras
  :commands (mc/compare-chars mc/compare-chars-backward mc/compare-chars-forward
            mc/cua-rectangle-to-multiple-cursors
            mc/remove-current-cursor mc/remove-duplicated-cursors)
  :config
  (progn
    (bind-keys :map mc/keymap
         ("C-. C-d" . mc/remove-current-cursor)
         ("C-. d" . mc/remove-duplicated-cursors)
         ("C-. =" . mc/compare-chars))
    (eval-after-load 'cua-base
'(bind-key "C-. C-," 'mc/cua-rectangle-to-multiple-cursors cua--rectangle-keymap))))
#+END_SRC

*** Expand region

    Expand region is an useful little tool.  With it I can select a
    higher region each time I hit ~C-@~.  For example, imagine we have
    the following function call in lisp (and that the caret is in the
    ~^~ position):

#+BEGIN_SRC
(hello (dolly))
         ^
#+END_SRC

    If I hit ~C-@~ once, I'll get this selected:

#+BEGIN_SRC
(hello (dolly))
        ^---^
#+END_SRC

    If I hit it once again, I'll get:

#+BEGIN_SRC
(hello (dolly))
       ^-----^
#+END_SRC

    And if I hit it again, I'll get:

#+BEGIN_SRC
(hello (dolly))
 ^-----------^
#+END_SRC

    Finally, if I hit it 4 times, the whole sexp will be selected:

#+BEGIN_SRC
(hello (dolly))
^-------------^
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :bind ("C-@" . er/expand-region))
#+END_SRC

*** Avy

    Avy allows me to jump to different parts of the current buffer.
    There are some useful pictures of how it works in [[https://github.com/abo-abo/avy][the repo]].

#+BEGIN_SRC emacs-lisp
(use-package avy)
#+END_SRC

*** Yasnippet

#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :demand
  :diminish
  :commands (yas-reload-all)
  :init
  (eval-when-compile
    ;; Silence missing function warnings
    (declare-function yas-global-mode "yasnippet.el"))
  :config
  (yas-global-mode t)
  (yas-reload-all))

(use-package yasnippet-snippets
  :pin melpa-stable
  :after yasnippet
  :config
  (yas-reload-all))
#+END_SRC


** Themes

   I switch between a big number of themes, sometimes several times a
   day, depending on my mood.  The ones I stick with as of now, are
   the following:

#+BEGIN_SRC emacs-lisp
(use-package xresources-theme :pin melpa)
(use-package doom-themes :pin melpa-stable)
(use-package spacemacs-theme :pin melpa)
(use-package idea-darkula-theme)
(use-package punpun-theme)
(use-package white-theme)
(use-package arjen-grey-theme)
(use-package atom-one-dark-theme)
(use-package birds-of-paradise-plus-theme)
(use-package bliss-theme)
(use-package cyberpunk-theme)
(use-package espresso-theme)
(use-package github-theme)
(use-package heroku-theme)
(use-package idea-darkula-theme)
(use-package plan9-theme)
(use-package soothe-theme)
(use-package subatomic-theme)
(use-package sublime-themes)
(use-package white-theme)
(use-package madhat2r-theme)
(use-package kosmos-theme)
(use-package nord-theme)
#+END_SRC

** Programming languages

   At the time of writing this, I mostly write scala, but I've used a
   number of languages previously:

*** Scala

#+BEGIN_SRC emacs-lisp
;; Enable scala-mode and sbt-mode
(use-package scala-mode
  :mode "\\.s\\(cala\\|bt\\)$")

(use-package sbt-mode
  :commands sbt-start sbt-command
  :config
  ;; WORKAROUND: https://github.com/ensime/emacs-sbt-mode/issues/31
  ;; allows using SPACE when in the minibuffer
  (substitute-key-definition
   'minibuffer-complete-word
   'self-insert-command
   minibuffer-local-completion-map))

;; Enable nice rendering of diagnostics like compile errors.
(use-package flycheck
  :init (global-flycheck-mode))

(use-package lsp-mode
  :init (setq lsp-prefer-flycheck nil)
  :hook (scala-mode . lsp))

(use-package lsp-ui
  :custom (lsp-ui-sideline-enable nil)
  :hook (lsp-mode . lsp-ui-mode))

(use-package company-lsp
  :config
  (push 'company-lsp company-backends))
#+END_SRC

*** others

#+BEGIN_SRC emacs-lisp
  (use-package haskell-mode
    :config (custom-set-variables '(haskell-stylish-on-save t))
    :mode "\\.hs\\'")

  (use-package idris-mode)

  (use-package nix-mode
    :commands nix-mode
    :init
    (add-to-list 'auto-mode-alist '("\\.nix\\'" . nix-mode))
    (add-to-list 'auto-mode-alist '("\\.nix.in\\'" . nix-mode))
    :hook (nix-mode-hook .rainbow-delimiters-mode))

  (use-package groovy-mode)
  (use-package yaml-mode)
  (use-package json-mode)
  (use-package reformatter
    :pin melpa-stable)

  (use-package dhall-mode
    :pin melpa
    :mode  "\\.dhall\\'")

  (use-package markdown-mode
    :commands (markdown-mode gfm-mode)
    :mode (("README\\.md\\'" . gfm-mode)
	   ("\\.md\\'" . markdown-mode)
	   ("\\.markdown\\'" . markdown-mode))
    :init (setq markdown-command "multimarkdown")
  
    :config
    (use-package markdown-toc))
#+END_SRC

** Some more configuration for when all packages has been loaded

#+BEGIN_SRC emacs-lisp
(require 'diminish)
(require 'bind-key)

(electric-pair-mode 1)
#+END_SRC

** Weird characters I write

   In a day to day basis, I only use the ~λ~ there, but who knows? Now
   I can write most of those letters :)

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "M-g a") "α") ; alpha
(global-set-key (kbd "M-g b") "β") ; beta
(global-set-key (kbd "M-g g") "γ") ; gamma
(global-set-key (kbd "M-g d") "δ") ; delta
(global-set-key (kbd "M-g e") "ε") ; epsilon
(global-set-key (kbd "M-g z") "ζ") ; zeta
(global-set-key (kbd "M-g h") "η") ; eta
(global-set-key (kbd "M-g q") "θ") ; theta
(global-set-key (kbd "M-g i") "ι") ; iota
(global-set-key (kbd "M-g k") "κ") ; kappa
(global-set-key (kbd "M-g l") "λ") ; lambda
(global-set-key (kbd "M-g m") "μ") ; mu
(global-set-key (kbd "M-g n") "ν") ; nu
(global-set-key (kbd "M-g x") "ξ") ; xi
(global-set-key (kbd "M-g o") "ο") ; omicron
(global-set-key (kbd "M-g p") "π") ; pi
(global-set-key (kbd "M-g r") "ρ") ; rho
(global-set-key (kbd "M-g s") "σ") ; psi
(global-set-key (kbd "M-g t") "τ") ; tau
(global-set-key (kbd "M-g u") "υ") ; upsilon
(global-set-key (kbd "M-g f") "ϕ") ; phi
(global-set-key (kbd "M-g j") "φ") ; phi
(global-set-key (kbd "M-g c") "χ") ; xi
(global-set-key (kbd "M-g y") "ψ") ; psi
(global-set-key (kbd "M-g w") "ω") ; omega
(global-set-key (kbd "M-g A") "Α") ; ALPHA
(global-set-key (kbd "M-g B") "Β") ; BETA
(global-set-key (kbd "M-g G") "Γ") ; GAMMA
(global-set-key (kbd "M-g D") "Δ") ; DELTA
(global-set-key (kbd "M-g E") "Ε") ; EPSILON
(global-set-key (kbd "M-g Z") "Ζ") ; ZETA
(global-set-key (kbd "M-g H") "Η") ; ETA
(global-set-key (kbd "M-g Q") "Θ") ; THETA
(global-set-key (kbd "M-g I") "Ι") ; IOTA
(global-set-key (kbd "M-g K") "Κ") ; KAPPA
(global-set-key (kbd "M-g L") "Λ") ; LAMBDA
(global-set-key (kbd "M-g M") "Μ") ; MU
(global-set-key (kbd "M-g N") "Ν") ; NU
(global-set-key (kbd "M-g X") "Ξ") ; XI
(global-set-key (kbd "M-g O") "Ο") ; OMICRON
(global-set-key (kbd "M-g P") "Π") ; PI
(global-set-key (kbd "M-g R") "Ρ") ; RHO
(global-set-key (kbd "M-g S") "Σ") ; PSI
(global-set-key (kbd "M-g T") "Τ") ; TAU
(global-set-key (kbd "M-g U") "Υ") ; UPSILON
(global-set-key (kbd "M-g F") "Φ") ; PHI
(global-set-key (kbd "M-g J") "Φ") ; PHI
(global-set-key (kbd "M-g C") "Χ") ; XI
(global-set-key (kbd "M-g Y") "Ψ") ; PSI
(global-set-key (kbd "M-g W") "Ω") ; OMEGA
(global-set-key (kbd "M-g .") "∘")
(global-set-key (kbd "M-g *") "⊛")

#+END_SRC

** Thanks

For this configuration I've been inspired by:

- [fn:2]anler
- [fn:3]danielmai
- [fn:4]jwiegley
- [fn:5]abo-abo

* Footnotes

[fn:1] https://github.com/pashky/restclient.el
[fn:2] https://github.com/anler/.emacs.d
[fn:3] https://github.com/danielmai
[fn:4] https://github.com/jwiegley
[fn:5] https://github.com/abo-abo
